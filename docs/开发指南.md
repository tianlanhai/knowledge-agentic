# 开发指南

**上海宇羲伏天智能科技有限公司出品**

## 文档说明

本文档提供知识库智能体项目的开发指南，包括架构扩展、配置管理、服务开发、前端开发等内容，帮助开发者快速上手和贡献代码。

---

## 目录

1. [项目结构](#一项目结构)
2. [AI提供商扩展指南](#二ai提供商扩展指南)
3. [依赖注入容器使用指南](#三依赖注入容器使用指南)
4. [配置管理开发指南](#四配置管理开发指南)
5. [服务层开发最佳实践](#五服务层开发最佳实践)
6. [前端组件开发指南](#六前端组件开发指南)
7. [开发环境配置](#七开发环境配置)
8. [测试指南](#八测试指南)

---

## 一、项目结构

### 1.1 后端项目结构

```
code/
├── app/
│   ├── main.py                      # 应用程序入口
│   ├── api/                         # API 路由层
│   │   └── v1/
│   │       ├── api.py               # 路由注册
│   │       └── endpoints/           # 具体 API 端点
│   ├── core/                        # 核心模块 - 设计模式实现
│   │   ├── di/                      # 依赖注入
│   │   ├── ai_provider/             # AI 提供商工厂
│   │   ├── adapters/                # 适配器模式
│   │   ├── strategies/              # 策略模式
│   │   ├── states/                  # 状态模式
│   │   ├── builders/                # 建造者模式
│   │   ├── proxies/                 # 代理模式
│   │   ├── decorators/              # 装饰器模式
│   │   ├── bridges/                 # 桥接模式
│   │   ├── composite/               # 组合模式
│   │   ├── visitors/                # 访问者模式
│   │   ├── iterators/               # 迭代器模式
│   │   ├── commands/                # 命令模式
│   │   ├── observers/               # 观察者模式
│   │   ├── flyweight/               # 享元模式
│   │   ├── config/                  # 配置管理
│   │   └── error_handling/          # 错误处理
│   ├── services/                    # 服务层
│   │   ├── chat/                    # 聊天服务模块
│   │   ├── agent/                   # 智能体服务
│   │   └── ...                      # 其他服务
│   ├── repositories/                # 数据访问层
│   ├── models/                      # 数据模型
│   ├── schemas/                     # Pydantic 模式定义
│   ├── db/                          # 数据库连接和工厂
│   └── utils/                       # 工具函数
├── tests/                           # 测试文件
└── pyproject.toml                   # 项目配置
```

### 1.2 前端项目结构

```
frontend/src/
├── components/                      # 组件库
│   ├── common/                      # 通用组件
│   │   ├── hocs/                    # 高阶组件
│   │   ├── renderers/               # 渲染器
│   │   ├── ComponentComposer.tsx    # 组件组合器
│   │   └── FormComposer.tsx         # 表单组合器
│   ├── features/                    # 功能模块组件
│   │   ├── Chat/                    # 聊天相关组件
│   │   ├── ModelConfig/             # 模型配置
│   │   └── ...                      # 其他功能模块
│   └── layout/                      # 布局组件
├── stores/                          # 状态管理
│   ├── chatStore.ts                 # 聊天状态
│   ├── conversationStore.ts         # 会话状态
│   └── storeMediator.ts             # 状态中介者
├── services/                        # 服务层
│   ├── chatService.ts               # 聊天服务
│   ├── baseService.ts               # 基础服务
│   └── cachedServiceProxy.ts        # 缓存代理
├── hooks/                           # 自定义 Hooks
├── types/                           # TypeScript 类型定义
├── utils/                           # 工具函数
├── core/                            # 核心逻辑
├── strategies/                      # 策略模式实现
└── composables/                     # 组合式函数
```

---

## 二、AI提供商扩展指南

### 2.1 概述

项目支持多种AI提供商，采用工厂模式和注册表模式，便于扩展新的提供商。

### 2.2 已支持的提供商

| 提供商 | 标识符 | 支持的组件 |
|--------|--------|-----------|
| OpenAI | `openai` | LLM、Embedding |
| Ollama | `ollama` | LLM、Embedding |
| 智谱AI | `zhipuai` | LLM、Embedding |
| DeepSeek | `deepseek` | LLM |
| MiniMax | `minimax` | LLM |
| Moonshot | `moonshot` | LLM |

### 2.3 添加新的LLM提供商

#### 步骤1: 创建提供商工厂类

在 `code/app/core/ai_provider/providers/` 目录下创建新文件：

```python
# -*- coding: utf-8 -*-
"""
上海宇羲伏天智能科技有限公司出品

文件级注释：新AI提供商工厂
内部逻辑：实现新AI提供商的工厂类
设计模式：工厂模式
"""

from typing import Dict, Any
from langchain_core.language_models.chat_models import BaseChatModel
from app.core.ai_provider.base import AIProviderBase
from app.core.ai_provider.config import AIProviderConfig


class NewProviderFactory(AIProviderBase):
    """
    类级注释：新AI提供商工厂
    职责：创建新AI提供商的LLM和Embedding实例
    """

    # 类变量：提供商标识符
    provider_type = "new_provider"

    def create_llm(
        self,
        config: AIProviderConfig
    ) -> BaseChatModel:
        """
        函数级注释：创建LLM实例
        参数：
            config: 提供商配置
        返回值：LLM实例
        """
        # 内部逻辑：根据配置创建LLM实例
        from new_provider import NewProviderLLM

        return NewProviderLLM(
            api_key=config.api_key,
            model=config.model,
            base_url=config.base_url,
            temperature=config.temperature,
            max_tokens=config.max_tokens,
        )

    def create_embedding(
        self,
        config: AIProviderConfig
    ):
        """
        函数级注释：创建Embedding实例
        参数：
            config: 提供商配置
        返回值：Embedding实例
        """
        from new_provider import NewProviderEmbeddings

        return NewProviderEmbeddings(
            api_key=config.api_key,
            model=config.embedding_model,
        )
```

#### 步骤2: 注册提供商

在 `code/app/core/ai_provider/__init__.py` 中导入并注册：

```python
from app.core.ai_provider.providers.new_provider import NewProviderFactory

# 注册到工厂注册表
AIProviderFactoryRegistry.register(
    AIProviderType.NEW_PROVIDER,
    NewProviderFactory
)
```

#### 步骤3: 更新枚举

在 `code/app/core/ai_provider/config.py` 中添加新的枚举值：

```python
class AIProviderType(Enum):
    OPENAI = "openai"
    OLLAMA = "ollama"
    ZHIPUAI = "zhipuai"
    DEEPSEEK = "deepseek"
    MINIMAX = "minimax"
    MOONSHOT = "moonshot"
    NEW_PROVIDER = "new_provider"  # 新增
```

#### 步骤4: 更新前端类型定义

在 `frontend/src/types/modelConfig.ts` 中添加：

```typescript
export type AIProviderType =
  | "openai"
  | "ollama"
  | "zhipuai"
  | "deepseek"
  | "minimax"
  | "moonshot"
  | "new_provider";  // 新增
```

### 2.4 测试新提供商

创建测试文件 `tests/providers/test_new_provider.py`：

```python
import pytest
from app.core.ai_provider import create_ai_provider


@pytest.mark.asyncio
async def test_new_provider_llm():
    """测试新提供商的LLM创建"""
    config = {
        "provider": "new_provider",
        "api_key": "test_key",
        "model": "test_model",
    }

    llm = create_ai_provider("llm", config)
    assert llm is not None


@pytest.mark.asyncio
async def test_new_provider_embedding():
    """测试新提供商的Embedding创建"""
    config = {
        "provider": "new_provider",
        "api_key": "test_key",
        "embedding_model": "test_embedding",
    }

    embedding = create_ai_provider("embedding", config)
    assert embedding is not None
```

---

## 三、依赖注入容器使用指南

### 3.1 概述

项目实现了轻量级的依赖注入容器（DI Container），支持三种服务生命周期。

### 3.2 服务生命周期

| 生命周期 | 说明 | 使用场景 |
|---------|------|---------|
| **TRANSIENT** | 每次请求创建新实例 | 无状态服务、工具类 |
| **SCOPED** | 同一作用域内共享实例 | 请求级别的服务、数据库会话 |
| **SINGLETON** | 全局唯一实例 | 配置服务、缓存服务 |

### 3.3 注册服务

```python
from app.core.di import ServiceContainer, ServiceLifetime, get_container

# 获取容器实例
container = get_container()

# 注册瞬态服务
container.register_transient(
    MyService,
    MyService
)

# 注册作用域服务
container.register_scoped(
    DatabaseService,
    DatabaseService
)

# 注册单例服务
container.register_singleton(
    ConfigService,
    ConfigService
)

# 注册为接口
container.register(
    MyServiceImpl,
    MyServiceImpl,
    lifetime=ServiceLifetime.SCOPED,
    as_interface=IMyService
)
```

### 3.4 获取服务

```python
from app.core.di import get_container

container = get_container()

# 直接获取
service = container.get_service(MyService)

# 通过接口获取
service = container.get_service(IMyService)
```

### 3.5 使用作用域

```python
from app.core.di import get_container

container = get_container()

# 创建作用域
async with container.create_scope() as scope:
    # 在作用域内获取服务
    db_service = scope.get_service(DatabaseService)

    # 同一作用域内获取的是同一实例
    db_service2 = scope.get_service(DatabaseService)
    assert db_service is db_service2

# 作用域结束，自动清理
```

### 3.6 自动依赖注入

服务可以通过构造函数自动注入依赖：

```python
class ChatService:
    """
    类级注释：聊天服务
    职责：处理聊天相关业务逻辑
    """

    def __init__(
        self,
        llm_factory: LLMFactory,      # 自动注入
        vector_store: VectorStore,    # 自动注入
        config: ConfigService         # 自动注入
    ):
        self._llm_factory = llm_factory
        self._vector_store = vector_store
        self._config = config

# 使用
chat_service = container.get_service(ChatService)
# 依赖会自动注入
```

### 3.7 最佳实践

1. **接口优先**: 通过接口注册和获取服务，便于测试和替换
2. **合理选择生命周期**:
   - 无状态服务使用 TRANSIENT
   - 有状态服务使用 SCOPED
   - 全局配置使用 SINGLETON
3. **避免循环依赖**: 通过重构设计避免循环依赖
4. **使用工厂函数**: 复杂的初始化逻辑使用工厂函数

---

## 四、配置管理开发指南

### 4.1 配置系统架构

项目采用模块化的配置管理架构：

```
config/
├── __init__.py           # 配置导出
├── base.py               # 配置基类
├── api_config.py         # API配置
├── cors_config.py        # CORS配置
├── llm_config.py         # LLM配置
├── db_config.py          # 数据库配置
├── storage_config.py     # 存储配置
├── security_config.py    # 安全配置
└── validators.py         # 配置验证器
```

### 4.2 添加新的配置模块

#### 步骤1: 创建配置类

```python
# -*- coding: utf-8 -*-
"""
上海宇羲伏天智能科技有限公司出品

文件级注释：新功能配置模块
内部逻辑：管理新功能的配置参数
"""

from pydantic import BaseModel, Field
from typing import Optional


class NewFeatureConfig(BaseModel):
    """
    类级注释：新功能配置
    职责：封装新功能的配置参数
    """
    # 功能开关
    enabled: bool = Field(default=False, description="是否启用新功能")

    # API配置
    api_endpoint: str = Field(default="", description="API端点")

    # 超时配置
    timeout: int = Field(default=30, description="请求超时时间（秒）")

    # 重试配置
    max_retries: int = Field(default=3, description="最大重试次数")

    class Config:
        """配置类元数据"""
        env_prefix = "NEW_FEATURE_"
        case_sensitive = False
```

#### 步骤2: 添加配置验证器

```python
# code/app/core/config/validators.py

class NewFeatureValidator:
    """新功能配置验证器"""

    @staticmethod
    def validate(config: NewFeatureConfig) -> bool:
        """
        函数级注释：验证新功能配置
        参数：
            config: 配置对象
        返回值：是否有效
        """
        if config.enabled and not config.api_endpoint:
            raise ValueError("启用新功能时必须配置API端点")

        if config.timeout <= 0:
            raise ValueError("超时时间必须大于0")

        return True
```

#### 步骤3: 集成到配置管理器

```python
# code/app/core/config/__init__.py

from .new_feature_config import NewFeatureConfig
from .validators import NewFeatureValidator

# 导出配置类
__all__ = ['NewFeatureConfig', 'NewFeatureValidator']
```

### 4.3 配置热更新

项目支持配置热更新，通过观察者模式通知订阅者：

```python
from app.core.config_manager import ConfigManager, ConfigEventType

# 获取配置管理器
config_manager = ConfigManager()

# 订阅配置变更
async def on_new_feature_config_change(config: dict):
    """配置变更回调"""
    new_config = NewFeatureConfig(**config)
    # 更新服务配置
    await update_service_config(new_config)

# 订阅事件
unsubscribe = await config_manager.subscribe(
    ConfigEventType.GLOBAL_CHANGED,
    on_new_feature_config_change
)

# 更新配置（会通知所有订阅者）
await config_manager.update_config(
    {"new_feature_enabled": True},
    ConfigEventType.GLOBAL_CHANGED
)

# 取消订阅
unsubscribe()
```

### 4.4 环境变量配置

支持通过环境变量覆盖配置：

```bash
# .env 文件
NEW_FEATURE_ENABLED=true
NEW_FEATURE_API_ENDPOINT=https://api.example.com
NEW_FEATURE_TIMEOUT=60
```

---

## 五、服务层开发最佳实践

### 5.1 服务层架构

服务层采用策略模式、外观模式和编排器模式：

```
services/
├── chat/                  # 聊天服务模块
│   ├── __init__.py
│   ├── orchestrator.py    # 编排器
│   ├── strategies/        # 策略实现
│   └── processors/        # 处理器
├── agent/                 # 智能体服务
└── ingest_service.py      # 数据摄入服务
```

### 5.2 创建新服务

#### 步骤1: 定义服务接口

```python
# -*- coding: utf-8 -*-
"""
上海宇羲伏天智能科技有限公司出品

文件级注释：新服务模块
内部逻辑：实现新功能的业务逻辑
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any


class INewService(ABC):
    """新服务接口"""

    @abstractmethod
    async def process(self, request: NewServiceRequest) -> NewServiceResponse:
        """
        函数级注释：处理请求
        参数：
            request: 服务请求
        返回值：服务响应
        """
        pass
```

#### 步骤2: 实现服务类

```python
class NewService(INewService):
    """
    类级注释：新服务实现
    职责：实现新功能的具体业务逻辑
    """

    def __init__(
        self,
        llm_factory: LLMFactory,
        vector_store: VectorStoreAdapter,
        config: ConfigService
    ):
        # 内部变量：依赖的服务
        self._llm_factory = llm_factory
        self._vector_store = vector_store
        self._config = config

    async def process(self, request: NewServiceRequest) -> NewServiceResponse:
        """
        函数级注释：处理请求
        内部逻辑：
            1. 验证请求参数
            2. 执行业务逻辑
            3. 返回响应结果
        """
        # 1. 验证请求
        self._validate_request(request)

        # 2. 执行业务逻辑
        result = await self._do_process(request)

        # 3. 构建响应
        return NewServiceResponse(
            success=True,
            data=result
        )

    def _validate_request(self, request: NewServiceRequest):
        """验证请求参数"""
        if not request.input_data:
            raise ValueError("输入数据不能为空")

    async def _do_process(self, request: NewServiceRequest) -> Dict[str, Any]:
        """执行业务逻辑"""
        # 具体实现
        pass
```

#### 步骤3: 注册到DI容器

```python
from app.core.di import get_container, ServiceLifetime

container = get_container()
container.register(
    INewService,
    NewService,
    lifetime=ServiceLifetime.SCOPED,
    as_interface=INewService
)
```

### 5.3 使用策略模式

当服务有多种实现方式时，使用策略模式：

```python
# 定义策略接口
class ProcessingStrategy(ABC):
    """处理策略接口"""

    @abstractmethod
    async def execute(self, data: Any) -> Any:
        pass

# 具体策略实现
class FastProcessingStrategy(ProcessingStrategy):
    """快速处理策略"""

    async def execute(self, data: Any) -> Any:
        # 快速处理逻辑
        pass

class AccurateProcessingStrategy(ProcessingStrategy):
    """精确处理策略"""

    async def execute(self, data: Any) -> Any:
        # 精确处理逻辑
        pass

# 在服务中使用策略
class NewService:
    def __init__(self):
        self._strategies = {
            "fast": FastProcessingStrategy(),
            "accurate": AccurateProcessingStrategy(),
        }

    async def process(self, request: NewServiceRequest) -> NewServiceResponse:
        # 根据请求选择策略
        strategy = self._strategies.get(request.strategy)
        return await strategy.execute(request.data)
```

### 5.4 使用编排器模式

对于复杂的服务流程，使用编排器模式：

```python
class NewServiceOrchestrator:
    """
    类级注释：新服务编排器
    设计模式：编排器模式
    职责：协调多个组件完成复杂业务流程
    """

    def __init__(
        self,
        validator: RequestValidator,
        processor: DataProcessor,
        enricher: DataEnricher,
        response_builder: ResponseBuilder
    ):
        self._validator = validator
        self._processor = processor
        self._enricher = enricher
        self._response_builder = response_builder

    async def execute(self, request: NewServiceRequest) -> NewServiceResponse:
        """
        函数级注释：编排执行流程
        内部逻辑：协调各组件按序执行
        """
        # 1. 验证请求
        validation_result = await self._validator.validate(request)
        if not validation_result.is_valid:
            return self._response_builder.build_error(validation_result.errors)

        # 2. 处理数据
        processed_data = await self._processor.process(request.data)

        # 3. 数据增强
        enriched_data = await self._enricher.enrich(processed_data)

        # 4. 构建响应
        return self._response_builder.build_success(enriched_data)
```

### 5.5 服务层最佳实践

1. **单一职责**: 每个服务只负责一个业务领域
2. **接口隔离**: 定义清晰的接口，避免客户端依赖不必要的方法
3. **依赖注入**: 通过构造函数注入依赖，便于测试
4. **异步优先**: 所有服务方法使用异步函数
5. **错误处理**: 统一的错误处理和日志记录

---

## 六、前端组件开发指南

### 6.1 前端架构

前端采用 React + TypeScript + Zustand 架构：

```
src/
├── components/              # 组件
│   ├── common/              # 通用组件
│   │   ├── hocs/            # 高阶组件
│   │   │   ├── withErrorBoundary.tsx
│   │   │   ├── withLoading.tsx
│   │   │   └── withPermission.tsx
│   │   └── renderers/       # 渲染器
│   └── features/            # 功能组件
├── stores/                  # 状态管理
│   ├── chatStore.ts         # 聊天状态
│   ├── conversationStore.ts # 会话状态
│   └── storeMediator.ts     # 状态中介者
├── services/                # 服务层
│   ├── chatService.ts       # 聊天服务
│   └── baseService.ts       # 基础服务
├── hooks/                   # 自定义Hooks
└── types/                   # 类型定义
```

### 6.2 创建新组件

#### 基础组件模板

```typescript
/**
 * 上海宇羲伏天智能科技有限公司出品
 *
 * 文件级注释：新功能组件
 * 内部逻辑：实现新功能的UI展示和交互
 */

import React, { useState, useCallback } from 'react';
import { message } from 'antd';
import { useNewFeature } from '@/hooks/useNewFeature';
import type { NewFeatureProps } from '@/types/newFeature';

/**
 * 新功能组件
 * @param props - 组件属性
 * @returns JSX元素
 */
export const NewFeature: React.FC<NewFeatureProps> = (props) => {
  // 内部变量：组件状态
  const [loading, setLoading] = useState(false);
  const [data, setData] = useState<DataType | null>(null);

  // 内部变量：自定义Hook
  const { fetchData, submitData } = useNewFeature();

  /**
   * 处理数据加载
   * 内部逻辑：加载失败时显示错误提示
   */
  const handleLoad = useCallback(async () => {
    try {
      setLoading(true);
      const result = await fetchData(props.id);
      setData(result);
    } catch (error) {
      message.error('加载失败');
      console.error(error);
    } finally {
      setLoading(false);
    }
  }, [props.id, fetchData]);

  /**
   * 处理数据提交
   * 内部逻辑：提交成功后显示成功提示
   */
  const handleSubmit = useCallback(async () => {
    try {
      setLoading(true);
      await submitData(data);
      message.success('提交成功');
    } catch (error) {
      message.error('提交失败');
      console.error(error);
    } finally {
      setLoading(false);
    }
  }, [data, submitData]);

  return (
    <div className="new-feature">
      {/* 组件内容 */}
    </div>
  );
};

export default NewFeature;
```

### 6.3 使用高阶组件

项目提供了多个高阶组件，用于增强组件功能：

```typescript
import { withErrorBoundary, withLoading, withPermission } from '@/components/common/hocs';

/**
 * 组合使用高阶组件
 * 内部逻辑：从右到左执行，withPermission最先执行
 */
export default withErrorBoundary(
  withLoading(
    withPermission(
      NewFeature,
      'new_feature:view'
    )
  )
);
```

### 6.4 使用状态管理

项目使用 Zustand 进行状态管理：

```typescript
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

/**
 * 新功能状态管理
 */
interface NewFeatureState {
  // 内部变量：状态数据
  data: DataType | null;
  loading: boolean;
  error: string | null;

  // 内部变量：操作方法
  setData: (data: DataType) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  clearError: () => void;
  reset: () => void;
}

/**
 * 新功能Store
 */
export const useNewFeatureStore = create<NewFeatureState>()(
  devtools(
    (set) => ({
      // 初始状态
      data: null,
      loading: false,
      error: null,

      // 操作方法
      setData: (data) => set({ data, error: null }),
      setLoading: (loading) => set({ loading }),
      setError: (error) => set({ error }),
      clearError: () => set({ error: null }),
      reset: () => set({ data: null, loading: false, error: null }),
    }),
    {
      name: 'NewFeatureStore',
    }
  )
);
```

### 6.5 自定义Hook

```typescript
import { useCallback } from 'react';
import { useNewFeatureStore } from '@/stores/newFeatureStore';
import { newFeatureService } from '@/services/newFeatureService';

/**
 * 使用新功能Hook
 * 内部逻辑：封装新功能相关的状态和操作
 */
export const useNewFeature = () => {
  // 内部变量：从Store获取状态和方法
  const { data, loading, error, setData, setLoading, setError } = useNewFeatureStore();

  /**
   * 获取数据
   */
  const fetchData = useCallback(async (id: string) => {
    try {
      setLoading(true);
      setError(null);
      const result = await newFeatureService.getData(id);
      setData(result);
      return result;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [setData, setLoading, setError]);

  /**
   * 提交数据
   */
  const submitData = useCallback(async (data: DataType) => {
    try {
      setLoading(true);
      setError(null);
      const result = await newFeatureService.submitData(data);
      return result;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [setLoading, setError]);

  return {
    // 状态
    data,
    loading,
    error,
    // 操作
    fetchData,
    submitData,
  };
};
```

### 6.6 前端最佳实践

1. **TypeScript优先**: 所有组件和函数使用类型定义
2. **组件拆分**: 大组件拆分为小组件，保持单一职责
3. **自定义Hook**: 复用逻辑提取为自定义Hook
4. **状态管理**: 复杂状态使用Zustand，简单状态使用useState
5. **错误处理**: 使用错误边界捕获组件错误

---

## 七、开发环境配置

### 7.1 后端环境配置

```bash
# 进入后端目录
cd code

# 安装依赖
pip install -e .

# 安装开发依赖
pip install -e ".[dev]"

# 配置环境变量
cp .env.example .env

# 运行开发服务器
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

### 7.2 前端环境配置

```bash
# 进入前端目录
cd frontend

# 安装依赖
pnpm install

# 配置环境变量
cp .env.example .env

# 运行开发服务器
pnpm dev
```

### 7.3 代码格式化

```bash
# 后端代码格式化
ruff format code/
ruff check code/

# 前端代码格式化
pnpm lint
pnpm format
```

---

## 八、测试指南

### 8.1 后端测试

#### 运行测试

```bash
# 运行所有测试
pytest

# 运行特定测试文件
pytest tests/test_design_patterns.py

# 运行特定测试函数
pytest tests/test_new_service.py::test_process

# 生成覆盖率报告
pytest --cov=app --cov-report=html
```

#### 编写测试

```python
import pytest
from httpx import AsyncClient
from app.main import app


@pytest.mark.asyncio
async def test_new_service_endpoint():
    """测试新服务端点"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post("/api/v1/new-service", json={
            "input_data": "test"
        })
        assert response.status_code == 200
        assert response.json()["success"] is True


@pytest.mark.asyncio
async def test_new_service_with_mock(mocker):
    """测试新服务（使用Mock）"""
    # Mock依赖
    mock_llm = mocker.patch('app.services.new_service.LLMFactory')
    mock_llm.return_value.create.return_value.generate.return_value = "mocked response"

    # 测试
    from app.services.new_service import NewService
    service = NewService(mock_llm, ...)
    result = await service.process(request)
    assert result.data == "mocked response"
```

### 8.2 前端测试

#### 运行测试

```bash
# 运行所有测试
pnpm test

# 运行特定测试文件
pnpm test NewFeature.test.tsx

# 生成覆盖率报告
pnpm test:coverage
```

#### 编写测试

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import NewFeature from '@/components/features/NewFeature';

describe('NewFeature', () => {
  it('should render correctly', () => {
    render(<NewFeature id="test" />);
    expect(screen.getByText('New Feature')).toBeInTheDocument();
  });

  it('should load data on mount', async () => {
    const mockFetch = vi.fn().mockResolvedValue({ data: 'test' });
    render(<NewFeature id="test" />);

    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalled();
    });
  });
});
```

### 8.3 测试最佳实践

1. **测试覆盖率**: 后端 >95%，前端 >80%
2. **测试隔离**: 每个测试独立运行，不依赖其他测试
3. **使用Mock**: Mock外部依赖，确保测试稳定性
4. **测试命名**: 清晰描述测试场景

---

**文档版本**: v1.0
**更新日期**: 2026-01-29
**作者**: 上海宇羲伏天智能科技有限公司
