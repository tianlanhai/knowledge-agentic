# 架构设计文档 - 设计模式篇

**上海宇羲伏天智能科技有限公司出品**

## 文档说明

本文档详细说明知识库智能体项目中应用的所有设计模式，包括实现原理、代码示例和使用场景。

---

## 目录

1. [创建型模式](#一创建型模式)
2. [结构型模式](#二结构型模式)
3. [行为型模式](#三行为型模式)
4. [设计模式应用总结](#四设计模式应用总结)

---

## 一、创建型模式

### 1.1 单例模式（Singleton Pattern）

**文件位置**: `code/app/core/di/service_container.py`

**设计意图**: 确保一个类只有一个实例，并提供全局访问点。

**实现代码**:

```python
class ServiceContainer:
    # 内部类变量：全局容器实例（单例）
    _instance: Optional['ServiceContainer'] = None

    def __new__(cls) -> 'ServiceContainer':
        """
        函数级注释：实现单例模式
        返回值：单例容器实例
        """
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
```

**使用场景**:
- 全局配置管理（`ConfigManager`）
- 服务容器（`ServiceContainer`）
- 数据库连接池

**设计优势**:
- 确保全局唯一实例
- 延迟初始化，节省资源
- 线程安全（通过`__new__`方法实现）

---

### 1.2 工厂模式（Factory Pattern）

**文件位置**: `code/app/core/ai_provider_factory.py`

**设计意图**: 定义创建对象的接口，让子类决定实例化哪一个类。

**实现代码**:

```python
class BaseFactory(ABC, Generic[T]):
    """
    类级注释：工厂基类，定义所有工厂类的通用行为
    设计模式：模板方法模式
    """

    @classmethod
    @abstractmethod
    def _get_default_config(cls) -> Dict[str, Any]:
        """获取默认配置（抽象方法，子类必须实现）"""
        pass

    @classmethod
    def create_with_config(cls, config: Optional[Dict[str, Any]] = None, **kwargs) -> T:
        """使用配置创建实例（模板方法）"""
        resolved_config = cls._resolve_config(config)
        provider = resolved_config.get("provider", "unknown")
        return cls._create_by_provider(provider, resolved_config, **kwargs)
```

**使用场景**:
- LLM提供商创建（`LLMFactory`）
- Embedding提供商创建（`EmbeddingFactory`）
- AI提供商创建（`AIProviderFactory`）
- 向量存储适配器创建（`VectorStoreAdapterFactory`）

**支持的提供商**:
- OpenAI
- Ollama
- 智谱AI (ZhipuAI)
- DeepSeek
- MiniMax
- Moonshot

**设计优势**:
- 解耦对象创建和使用
- 支持运行时配置切换
- 易于扩展新的提供商

---

### 1.3 抽象工厂模式（Abstract Factory Pattern）

**文件位置**: `code/app/core/ai_provider/`

**设计意图**: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**实现结构**:

```
AIProviderFactory (抽象工厂)
    ├── OllamaProviderFactory (具体工厂)
    ├── ZhipuAIProviderFactory (具体工厂)
    ├── OpenAIProviderFactory (具体工厂)
    └── ...
```

**使用场景**:
- 创建不同提供商的LLM实例
- 创建不同提供商的Embedding实例
- 批量创建AI组件

**设计优势**:
- 保证产品族的一致性
- 新增产品族无需修改现有代码
- 支持产品族的切换

---

### 1.4 建造者模式（Builder Pattern）

**文件位置**: `code/app/core/builders/chat_builder.py`

**设计意图**: 将复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

**实现代码**:

```python
class ChatBuilder:
    """
    类级注释：聊天构建器
    设计模式：建造者模式
    职责：分步骤构建复杂的聊天对象
    """

    def __init__(self):
        self._messages = []
        self._config = LLMConfig()
        self._tools = []

    def add_message(self, role: MessageRole, content: str) -> 'ChatBuilder':
        """添加消息"""
        self._messages.append(Message(role=role, content=content))
        return self

    def set_config(self, config: LLMConfig) -> 'ChatBuilder':
        """设置配置"""
        self._config = config
        return self

    def add_tool(self, tool: Tool) -> 'ChatBuilder':
        """添加工具"""
        self._tools.append(tool)
        return self

    def build(self) -> ChatRequest:
        """构建聊天请求"""
        return ChatRequest(
            messages=self._messages,
            config=self._config,
            tools=self._tools
        )
```

**使用场景**:
- 构建复杂的聊天请求
- 构建文档处理流程
- 构建测试数据

**设计优势**:
- 分步骤构建，代码清晰
- 支持链式调用
- 易于扩展构建步骤

---

### 1.5 原型模式（Prototype Pattern）

**文件位置**: `code/app/core/prototype.py`

**设计意图**: 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**使用场景**:
- 文档对象复制
- 配置模板复制
- 测试数据创建

**设计优势**:
- 避免复杂的初始化过程
- 动态获取对象类型
- 提高性能（避免创建开销）

---

## 二、结构型模式

### 2.1 适配器模式（Adapter Pattern）

**文件位置**: `code/app/core/adapters/vector_store_adapter.py`

**设计意图**: 将一个类的接口转换成客户希望的另外一个接口。

**实现代码**:

```python
class VectorStoreAdapter(ABC):
    """
    类级注释：向量存储适配器抽象基类
    设计模式：适配器模式 - 目标接口
    职责：
        1. 定义统一的向量存储接口
        2. 将不同的向量存储实现适配为统一接口
        3. 支持运行时切换不同的向量存储后端
    """

    @abstractmethod
    async def add_documents(self, documents: List[Document], **kwargs) -> List[str]:
        """添加文档到向量存储"""
        pass

    @abstractmethod
    async def similarity_search(self, query: SearchQuery, **kwargs) -> List[SearchResult]:
        """相似度搜索"""
        pass
```

**适配的实现**:
- ChromaDB适配器（`ChromaAdapter`）
- 可扩展：FAISS、Pinecone、Weaviate等

**使用场景**:
- 统一向量存储接口
- 多向量存储后端支持
- 存储后端切换

**设计优势**:
- 客户端代码无需关心具体实现
- 新增后端只需实现适配器
- 便于测试和Mock

---

### 2.2 桥接模式（Bridge Pattern）

**文件位置**: `code/app/core/bridges/llm_bridge.py`

**设计意图**: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。

**实现代码**:

```python
# 实现接口
class LLMImplementation(ABC):
    """LLM 实现抽象接口"""

    @abstractmethod
    async def generate(self, messages: List[Message], config: LLMConfig) -> LLMResponse:
        pass

# 具体实现
class OllamaImplementation(LLMImplementation):
    """Ollama LLM 实现"""
    async def generate(self, messages, config):
        # Ollama特定实现
        pass

# 抽象
class LLMAbstraction:
    """LLM 抽象层"""

    def __init__(self, implementation: LLMImplementation):
        self._implementation = implementation

    def set_implementation(self, implementation: LLMImplementation):
        """切换实现"""
        self._implementation = implementation
```

**使用场景**:
- LLM提供商切换
- Embedding提供商切换
- 多模型A/B测试

**设计优势**:
- 抽象和实现分离
- 运行时切换实现
- 符合开闭原则

---

### 2.3 组合模式（Composite Pattern）

**文件位置**: `code/app/core/composite/document_node.py`

**设计意图**: 将对象组合成树形结构以表示"部分-整体"的层次结构。

**实现代码**:

```python
# 组件接口
class DocumentNode(ABC):
    """文档节点抽象基类"""

    @abstractmethod
    def size(self) -> int:
        """获取节点大小"""
        pass

    @abstractmethod
    def count(self) -> int:
        """计算节点包含的文件数量"""
        pass

# 叶子节点
class FileNode(DocumentNode):
    """文件节点类"""
    def size(self) -> int:
        return self.file_size

# 组合节点
class FolderNode(DocumentNode):
    """文件夹节点类"""
    def __init__(self, ...):
        self._children: List[DocumentNode] = []

    def add_child(self, child: DocumentNode):
        self._children.append(child)

    def size(self) -> int:
        return sum(child.size() for child in self._children)
```

**使用场景**:
- 文档目录树管理
- 权限树管理
- 分类层级结构

**设计优势**:
- 统一处理单个节点和节点集合
- 客户端无需区分文件和文件夹
- 易于扩展新的节点类型

---

### 2.4 装饰器模式（Decorator Pattern）

**文件位置**: `code/app/core/decorators/`

**设计意图**: 动态地给一个对象添加一些额外的职责。

**实现代码**:

```python
# 敏感信息过滤装饰器
def filter_sensitive_data(func):
    """
    函数级注释：敏感信息过滤装饰器
    设计模式：装饰器模式
    职责：在函数执行前后进行敏感信息过滤
    """
    @wraps(func)
    async def wrapper(*args, **kwargs):
        # 执行前过滤输入
        filtered_args = _filter_input(args)

        # 执行原函数
        result = await func(*filtered_args, **kwargs)

        # 执行后过滤输出
        return _filter_output(result)
    return wrapper

# 弹性重试装饰器
def retry_on_failure(max_retries: int = 3, backoff: float = 1.0):
    """
    函数级注释：弹性重试装饰器
    设计模式：装饰器模式
    职责：在函数失败时自动重试
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_retries - 1:
                        raise
                    await asyncio.sleep(backoff * (2 ** attempt))
        return wrapper
    return decorator
```

**使用场景**:
- 敏感信息过滤
- 弹性重试
- 性能监控
- 日志记录
- 权限验证

**设计优势**:
- 不修改原有代码
- 可组合多个装饰器
- 运行时动态添加功能

---

### 2.5 外观模式（Facade Pattern）

**文件位置**: `code/app/services/chat_service.py`

**设计意图**: 为子系统中的一组接口提供一个一致的界面。

**实现代码**:

```python
class ChatService:
    """
    类级注释：聊天服务（外观模式）
    设计模式：外观模式
    职责：提供简化的统一接口，隐藏复杂的子系统
    """

    def __init__(
        self,
        llm_factory: LLMFactory,
        vector_store: VectorStoreAdapter,
        agent_service: AgentService
    ):
        self._llm_factory = llm_factory
        self._vector_store = vector_store
        self._agent_service = agent_service

    async def chat(self, request: ChatRequest) -> ChatResponse:
        """
        函数级注释：统一的聊天接口
        内部逻辑：协调多个子系统完成聊天
        """
        # 1. 检索相关文档
        docs = await self._vector_store.search(request.query)

        # 2. 调用LLM生成回答
        llm = self._llm_factory.create()
        response = await llm.generate(request.messages, docs)

        # 3. 智能体后续处理（如需要）
        if request.use_agent:
            response = await self._agent_service.process(response)

        return response
```

**使用场景**:
- API接口层
- 复杂业务流程封装
- 第三方系统集成

**设计优势**:
- 简化客户端调用
- 隐藏子系统复杂性
- 降低耦合度

---

### 2.6 代理模式（Proxy Pattern）

**文件位置**: `code/app/core/proxies/`、`frontend/src/services/cachedServiceProxy.ts`

**设计意图**: 为其他对象提供一种代理以控制对这个对象的访问。

**实现代码**:

```python
class CachedServiceProxy:
    """
    类级注释：缓存服务代理
    设计模式：代理模式
    职责：为服务添加缓存功能
    """

    def __init__(self, service: Any, ttl: int = 300):
        self._service = service
        self._cache = {}
        self._ttl = ttl

    async def get_documents(self, doc_id: str) -> Document:
        """获取文档（带缓存）"""
        # 检查缓存
        if doc_id in self._cache:
            cached, timestamp = self._cache[doc_id]
            if time.time() - timestamp < self._ttl:
                return cached

        # 调用真实服务
        doc = await self._service.get_documents(doc_id)

        # 更新缓存
        self._cache[doc_id] = (doc, time.time())
        return doc
```

**使用场景**:
- 服务缓存
- 懒加载
- 访问控制
- 日志记录

**设计优势**:
- 不修改真实服务
- 动态添加功能
- 控制访问权限

---

### 2.7 享元模式（Flyweight Pattern）

**文件位置**: `code/app/core/flyweight/chunk_flyweight.py`

**设计意图**: 运用共享技术有效地支持大量细粒度的对象。

**实现代码**:

```python
class ChunkFlyweight:
    """
    类级注释：文档片段享元
    设计模式：享元模式
    职责：共享重复的文档片段，减少内存占用
    """

    # 内部类变量：享元池
    _pool: Dict[str, 'ChunkFlyweight'] = {}

    def __init__(self, content: str):
        self.content = content

    @classmethod
    def get_flyweight(cls, content: str) -> 'ChunkFlyweight':
        """获取享元对象"""
        # 生成内容的哈希作为键
        key = hashlib.md5(content.encode()).hexdigest()

        if key not in cls._pool:
            cls._pool[key] = ChunkFlyweight(content)

        return cls._pool[key]
```

**使用场景**:
- 文档片段共享
- 配置对象共享
- 大量相似对象的内存优化

**设计优势**:
- 减少内存占用
- 提高性能
- 共享不可变状态

---

## 三、行为型模式

### 3.1 策略模式（Strategy Pattern）

**文件位置**: `code/app/core/strategies/strategy.py`

**设计意图**: 定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。

**实现代码**:

```python
# 策略接口
class ChatStrategy(ABC):
    """聊天策略抽象基类"""

    @abstractmethod
    async def execute(self, request: ChatRequest, db: AsyncSession) -> ChatAnswer:
        pass

# 具体策略
class RAGStrategy(ChatStrategy):
    """RAG对话策略"""

    async def execute(self, request: ChatRequest, db: AsyncSession) -> ChatAnswer:
        # 1. 检索相关文档
        retrieved_docs = await self._vector_store.search(request.question)

        # 2. 构建上下文
        context = self._build_context(retrieved_docs)

        # 3. 生成回答
        answer = await self._llm.generate(context, request.question)
        return ChatAnswer(text=answer, sources_data=retrieved_docs)

class AgentStrategy(ChatStrategy):
    """智能体对话策略"""

    async def execute(self, request: ChatRequest, db: AsyncSession) -> ChatAnswer:
        # 智能体特定逻辑
        pass
```

**使用场景**:
- 聊天策略选择（RAG/Agent）
- 重试策略
- 渲染策略

**设计优势**:
- 算法可自由切换
- 避免多重条件语句
- 符合开闭原则

---

### 3.2 观察者模式（Observer Pattern）

**文件位置**: `code/app/core/config_manager.py`、`code/app/core/observers/observer.py`

**设计意图**: 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知。

**实现代码**:

```python
class ConfigManager:
    """
    类级注释：配置管理器
    设计模式：单例模式 + 观察者模式
    """

    def __init__(self):
        # 内部变量：事件监听器映射表
        self._listeners: Dict[ConfigEventType, List[Callable]] = {
            event_type: []
            for event_type in ConfigEventType
        }

    async def subscribe(
        self,
        event_type: ConfigEventType,
        callback: Callable[[Dict[str, Any]], Any]
    ) -> Callable[[], None]:
        """
        函数级注释：订阅配置变更事件
        设计模式：观察者模式 - 订阅主题
        """
        self._listeners[event_type].append(callback)

        # 返回取消订阅函数
        def unsubscribe() -> None:
            if callback in self._listeners[event_type]:
                self._listeners[event_type].remove(callback)

        return unsubscribe

    async def update_config(
        self,
        config: Dict[str, Any],
        event_type: ConfigEventType
    ) -> None:
        """更新配置并通知订阅者"""
        self._config.update(config)
        await self._notify_listeners(event_type, config)
```

**使用场景**:
- 配置变更通知
- 事件系统
- 消息队列

**设计优势**:
- 解耦发布者和订阅者
- 支持动态订阅/取消
- 一对多通知

---

### 3.3 命令模式（Command Pattern）

**文件位置**: `code/app/core/commands/`、`code/app/core/commands.py`

**设计意图**: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。

**实现代码**:

```python
# 命令接口
class Command(ABC):
    """命令抽象基类"""

    @abstractmethod
    async def execute(self) -> Any:
        pass

    @abstractmethod
    async def undo(self) -> Any:
        pass

# 具体命令
class IngestDocumentCommand(Command):
    """文档摄入命令"""

    def __init__(self, document_service, file_path: str):
        self._service = document_service
        self._file_path = file_path
        self._result = None

    async def execute(self) -> Any:
        """执行文档摄入"""
        self._result = await self._service.ingest_file(self._file_path)
        return self._result

    async def undo(self) -> Any:
        """撤销文档摄入"""
        if self._result:
            await self._service.delete_document(self._result.document_id)
```

**使用场景**:
- 业务操作封装
- 撤销/重做
- 任务队列
- 事务处理

**设计优势**:
- 请求发送者与接收者解耦
- 支持命令队列
- 可撤销操作

---

### 3.4 状态模式（State Pattern）

**文件位置**: `code/app/core/states/chat_states.py`、`code/app/core/states/document_states.py`

**设计意图**: 允许一个对象在其内部状态改变时改变它的行为。

**实现代码**:

```python
# 状态接口
class ChatState(ABC):
    """聊天状态抽象基类"""

    @abstractmethod
    async def handle_input(self, context: ChatContext, user_input: str) -> 'ChatState':
        pass

# 具体状态
class IdleState(ChatState):
    """空闲状态"""

    async def handle_input(self, context: ChatContext, user_input: str) -> ChatState:
        context.add_message("user", user_input)
        return ProcessingState()

class ProcessingState(ChatState):
    """处理中状态"""

    async def handle_input(self, context: ChatContext, user_input: str) -> ChatState:
        # 生成AI回复
        response = await context.generate_response()
        context.add_message("assistant", response)
        return IdleState()
```

**使用场景**:
- 聊天状态管理
- 文档处理状态
- 工作流状态

**设计优势**:
- 状态转换清晰
- 消除条件语句
- 易于添加新状态

---

### 3.5 责任链模式（Chain of Responsibility Pattern）

**文件位置**: `code/app/core/validation_chain.py`、`code/app/core/error_handling/error_chain.py`

**设计意图**: 为解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。

**实现代码**:

```python
class Validator(ABC):
    """验证器抽象基类"""

    def __init__(self, next_validator: Optional['Validator'] = None):
        self._next = next_validator

    async def validate(self, data: Dict[str, Any]) -> ValidationResult:
        """验证数据"""
        # 当前验证器验证
        result = self._do_validate(data)
        if not result.is_valid:
            return result

        # 传递给下一个验证器
        if self._next:
            return await self._next.validate(data)

        return result

    @abstractmethod
    def _do_validate(self, data: Dict[str, Any]) -> ValidationResult:
        pass

# 具体验证器
class RequiredFieldValidator(Validator):
    """必填字段验证器"""

    def _do_validate(self, data: Dict[str, Any]) -> ValidationResult:
        if "required_field" not in data:
            return ValidationResult(False, "缺少必填字段")
        return ValidationResult(True)
```

**使用场景**:
- 请求验证链
- 错误处理链
- 日志处理链

**设计优势**:
- 解耦发送者和接收者
- 灵活的责任分配
- 易于扩展

---

### 3.6 访问者模式（Visitor Pattern）

**文件位置**: `code/app/core/visitors/document_visitor.py`

**设计意图**: 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

**实现代码**:

```python
# 可访问元素
class Document(Visitable):
    """文档数据类"""

    def accept(self, visitor: "DocumentVisitor") -> Any:
        return visitor.visit_document(self)

# 访问者接口
class DocumentVisitor(ABC):
    """文档访问者抽象基类"""

    @abstractmethod
    def visit_document(self, document: Document) -> Any:
        pass

    @abstractmethod
    def visit_chunk(self, chunk: DocumentChunk) -> Any:
        pass

# 具体访问者
class MarkdownExportVisitor(DocumentVisitor):
    """Markdown导出访问者"""

    def visit_document(self, document: Document) -> ExportResult:
        content = f"# {document.title}\n\n{document.content}"
        return ExportResult(content, "markdown", len(content))

    def visit_chunk(self, chunk: DocumentChunk) -> ExportResult:
        content = f"## Chunk {chunk.chunk_index}\n\n{chunk.content}"
        return ExportResult(content, "markdown", len(content))
```

**使用场景**:
- 文档导出（Markdown、JSON、TXT）
- 文档分析
- 数据格式转换

**设计优势**:
- 新增操作无需修改元素类
- 相关操作集中管理
- 可组合多个访问者

---

### 3.7 迭代器模式（Iterator Pattern）

**文件位置**: `code/app/core/iterators/batch_iterator.py`、`code/app/core/iterators/document_iterator.py`

**设计意图**: 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。

**实现代码**:

```python
class BatchIterator:
    """
    类级注释：批处理迭代器
    设计模式：迭代器模式
    职责：分批处理大量数据
    """

    def __init__(self, items: List[Any], batch_size: int = 100):
        self._items = items
        self._batch_size = batch_size
        self._index = 0

    def __iter__(self) -> 'BatchIterator':
        return self

    def __next__(self) -> List[Any]:
        if self._index >= len(self._items):
            raise StopIteration

        batch = self._items[self._index:self._index + self._batch_size]
        self._index += self._batch_size
        return batch
```

**使用场景**:
- 文档批量处理
- 数据库结果集遍历
- 大文件分块读取

**设计优势**:
- 隐藏内部结构
- 支持多种遍历方式
- 统一接口

---

### 3.8 中介者模式（Mediator Pattern）

**文件位置**: `code/app/core/config_mediator.py`、`code/app/core/service_mediator.py`

**设计意图**: 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用。

**实现代码**:

```python
class ConfigMediator:
    """
    类级注释：配置中介者
    设计模式：中介者模式
    职责：协调不同模块间的配置交互
    """

    def __init__(self):
        self._components: Dict[str, Any] = {}

    def register(self, name: str, component: Any):
        """注册组件"""
        self._components[name] = component

    def notify(self, sender: str, event: str, data: Any):
        """通知其他组件"""
        for name, component in self._components.items():
            if name != sender:
                component.handle_event(event, data)
```

**使用场景**:
- 组件间通信
- 事件协调
- 复杂交互管理

**设计优势**:
- 降低耦合度
- 集中管理交互
- 易于维护

---

### 3.9 模板方法模式（Template Method Pattern）

**文件位置**: `code/app/core/base_factory.py`

**设计意图**: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

**实现代码**:

```python
class BaseFactory(ABC, Generic[T]):
    """
    类级注释：工厂基类
    设计模式：模板方法模式
    """

    @classmethod
    def _resolve_config(cls, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        函数级注释：解析配置优先级（模板方法）
        内部逻辑：传入配置 > 运行时配置 > 默认配置
        """
        if config:
            return config
        if cls._runtime_config:
            return cls._runtime_config
        # 内部逻辑：调用子类实现的默认配置获取方法
        return cls._get_default_config()

    @classmethod
    @abstractmethod
    def _get_default_config(cls) -> Dict[str, Any]:
        """获取默认配置（抽象方法，子类必须实现）"""
        pass
```

**使用场景**:
- 工厂基类
- 服务基类
- 处理流程基类

**设计优势**:
- 代码复用
- 算法骨架稳定
- 子类灵活实现

---

### 3.10 依赖注入模式（Dependency Injection Pattern）

**文件位置**: `code/app/core/di/service_container.py`

**设计意图**: 将依赖关系的创建和使用分离，实现松耦合。

**实现代码**:

```python
class ServiceContainer:
    """
    类级注释：服务容器（依赖注入容器）
    设计模式：单例模式 + 依赖注入模式
    """

    def register(
        self,
        service_type: Type[T],
        factory: Callable[..., T],
        lifetime: ServiceLifetime = ServiceLifetime.TRANSIENT
    ) -> 'ServiceContainer':
        """注册服务"""
        dependencies = self._get_dependencies(factory)
        descriptor = ServiceDescriptor(
            factory=factory,
            lifetime=lifetime,
            dependencies=dependencies
        )
        self._services[service_type] = descriptor
        return self

    def get_service(self, service_type: Type[T]) -> T:
        """获取服务实例"""
        if service_type not in self._services:
            raise ValueError(f"服务未注册: {service_type.__name__}")
        return self._create_service(service_type, None)
```

**生命周期**:
- **TRANSIENT**: 瞬态 - 每次请求创建新实例
- **SCOPED**: 作用域 - 同一作用域内共享实例
- **SINGLETON**: 单例 - 全局唯一实例

**使用场景**:
- 服务注册和解析
- 依赖注入
- 生命周期管理

**设计优势**:
- 解耦组件依赖
- 支持生命周期管理
- 便于测试和Mock

---

## 四、设计模式应用总结

### 4.1 设计模式统计

| 分类 | 设计模式 | 应用数量 | 核心文件 |
|-----|---------|---------|---------|
| **创建型** | 单例模式 | 2 | ServiceContainer、ConfigManager |
| | 工厂模式 | 3 | LLMFactory、EmbeddingFactory、BaseFactory |
| | 抽象工厂 | 1 | AIProviderFactory |
| | 建造者模式 | 1 | ChatBuilder |
| | 原型模式 | 1 | prototype.py |
| **结构型** | 适配器模式 | 2 | VectorStoreAdapter、ChromaAdapter |
| | 桥接模式 | 2 | LLMBridge、EmbeddingBridge |
| | 组合模式 | 1 | document_node.py |
| | 装饰器模式 | 2 | 敏感信息过滤、弹性重试 |
| | 外观模式 | 1 | ChatService |
| | 代理模式 | 1 | CachedServiceProxy |
| | 享元模式 | 1 | chunk_flyweight.py |
| **行为型** | 策略模式 | 3 | ChatStrategy、RetryStrategy、RenderStrategy |
| | 观察者模式 | 2 | ConfigManager、Observer |
| | 命令模式 | 1 | commands/ |
| | 状态模式 | 2 | ChatState、DocumentState |
| | 责任链模式 | 2 | ValidationChain、ErrorChain |
| | 访问者模式 | 1 | document_visitor.py |
| | 迭代器模式 | 2 | BatchIterator、DocumentIterator |
| | 中介者模式 | 2 | ConfigMediator、ServiceMediator |
| | 模板方法模式 | 1 | BaseFactory |
| | 依赖注入 | 1 | ServiceContainer |
| **总计** | **17种** | **30+** | - |

### 4.2 设计原则遵循

| 设计原则 | 说明 | 应用体现 |
|---------|------|---------|
| **单一职责 (SRP)** | 一个类只负责一件事 | 每个策略类只负责一种算法 |
| **开闭原则 (OCP)** | 对扩展开放，对修改关闭 | 新增提供商只需实现接口 |
| **里氏替换 (LSP)** | 子类可替换父类 | 所有具体实现可替换抽象类 |
| **接口隔离 (ISP)** | 接口最小化 | VectorStoreAdapter只定义必要方法 |
| **依赖倒置 (DIP)** | 依赖抽象不依赖具体 | ServiceContainer依赖类型注解 |

### 4.3 设计模式协作图

```
┌─────────────────────────────────────────────────────────────────┐
│                        应用层 (API)                              │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                     服务层 (外观模式)                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ ChatService  │  │ IngestService│  │  AgentService│          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                                │
                ┌───────────────┼───────────────┐
                ▼               ▼               ▼
        ┌───────────┐   ┌───────────┐   ┌───────────┐
        │ 策略模式  │   │ 工厂模式  │   │ 依赖注入  │
        │ (策略选择)│   │ (对象创建)│   │ (服务管理)│
        └───────────┘   └───────────┘   └───────────┘
                │               │               │
                └───────────────┼───────────────┘
                                ▼
        ┌───────────────────────────────────────┐
        │         核心组件层                    │
        │  ┌──────────┐  ┌──────────┐          │
        │  │ 桥接模式 │  │ 适配器模式│          │
        │  └──────────┘  └──────────┘          │
        └───────────────────────────────────────┘
                                │
                                ▼
        ┌───────────────────────────────────────┐
        │         基础设施层                    │
        │  ┌──────────┐  ┌──────────┐          │
        │  │ 数据库   │  │ 向量库   │          │
        │  └──────────┘  └──────────┘          │
        └───────────────────────────────────────┘
```

### 4.4 设计模式带来的价值

1. **可维护性**: 清晰的架构分层和模式应用使代码易于理解和修改
2. **可扩展性**: 新增功能（如AI提供商）无需修改现有代码
3. **可测试性**: 依赖注入和接口抽象使单元测试更容易编写
4. **灵活性**: 策略模式、桥接模式等支持运行时切换实现
5. **代码复用**: 模板方法模式、组合模式等促进代码复用

---

**文档版本**: v1.0
**更新日期**: 2026-01-29
**作者**: 上海宇羲伏天智能科技有限公司
